package com.maxeler.examples.dynamicgap;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.networking.v1.framed_kernels.FramedLinkType;

public class Preprocessor extends Kernel {

	public static String OUTPUT_GAP_SIZE = "gapSize";
	public static String OUTPUT_FRAME = "outputFrame";
	public static String INPUT = "inputFrame";

	protected Preprocessor(KernelParameters parameters) {
		super(parameters);

		flush.disabled();

		FramedLinkType linkType = Types.linkWithGapIndicator;


		NonBlockingInput<DFEStruct> input = io.nonBlockingInput(INPUT,
				linkType.getDFEStructType(),
				constant.var(true),
				linkType.getDFEStructType().getPositionForField(linkType.getEOF()),
				DelimiterMode.EOF_POSITION,
				0, // No inter-frame-gap
				NonBlockingMode.NO_TRICKLING);



		/*
		 * Based on the input frame, find out what the inter-frame-gap should be.
		 *
		 * Lets assume the 20th byte (0 base) of the packet is the MessageType.
		 * If MessageType = 'G' then insert a Gap of 100 cycles. Otherwise, Gap = 0.
		 */

		DFEStruct inputStruct = input.data;
		DFEVar data = (DFEVar) inputStruct[linkType.getData()];
		DFEVar sof = (DFEVar) inputStruct[linkType.getSOF()];


		// Get 20th byte
		DFEVar messageType = getByte(data, 20);
		DFEVar requiredGap = messageType === constant.var(dfeUInt(8), 'G') ? constant.var(dfeUInt(8), 100) : constant.var(dfeUInt(8), 0);

		io.output(OUTPUT_GAP_SIZE, dfeUInt(8), input.valid & sof) <== requiredGap;

		// Pass the actual packet right through...
		io.output(OUTPUT_FRAME, linkType.getDFEStructType(), input.valid) <== input.data;
	}

	public DFEVar getByte(DFEVar data, int offset) {
		int bytesPerWord = data.getType().getTotalBytes();

		int wordOffset = offset / bytesPerWord;
		int byteOffset = offset % bytesPerWord;

		// 8 bits in a byte...
		return stream.offset(data, wordOffset).slice(byteOffset * 8, 8).cast(dfeUInt(8));
	}

}
