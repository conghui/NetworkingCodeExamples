package com.maxeler.examples.dynamicgap;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPullInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.DFEsmFifoConfig;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.buffer.DFEsmFifo;
import com.maxeler.statemachine.utils.SMUtils;

public class GapGenerator extends ManagerStateMachine {
	public static String INPUT_GAP_SIZE = "gapSize";
	public static String INPUT_FRAME = "inputFrame";
	public static String OUTPUT_FRAME = "outputFrame";

	public enum States {
		WAIT_FOR_GAP,
		PIPE_GAP,
		PASS_DATA,
		PASS_GAP
	}

	public GapGenerator(DFEManager owner) {
		super(owner);

		DFEStructType linkStructType = Types.linkWithGapIndicator.getDFEStructType();
		int linkWidth = linkStructType.getTotalBits();
		int stallLatency = 16;

		DFEsmPullInput gapSizeInput = io.pullInput(INPUT_GAP_SIZE, dfeUInt(8));
		DFEsmPushInput frameInput = io.pushInput(INPUT_FRAME, dfeUInt(linkWidth), stallLatency);
		DFEsmPushOutput frameOutput = io.pushOutput(OUTPUT_FRAME, dfeUInt(linkWidth), stallLatency);

		DFEsmStateValue outputReg = state.value(dfeUInt(linkWidth));
		DFEsmStateValue outputRegValid = state.value(dfeBool(), false);
		frameOutput.valid <== outputRegValid;
		frameOutput <== outputReg;
		DFEsmStateValue outputStall = state.value(dfeBool(), true);
		outputStall.next <== frameOutput.stall;

		int depth = 512;
		DFEsmFifoConfig config = new DFEsmFifoConfig();
		config.setProgrammableFull(depth - (stallLatency+2));
		config.setIsFirstWordFallThrough();
		DFEsmFifo inputFifo = buffer.fifo(dfeUInt(linkWidth), depth, config);

		inputFifo.input.dataIn <== frameInput;
		inputFifo.input.writeEnable <== frameInput.valid;
		frameInput.stall <== inputFifo.input.progFull;

		DFEsmStateEnum<States> currentState = state.enumerated(States.class, States.WAIT_FOR_GAP);
		DFEsmStateValue gapCounter = state.value(dfeUInt(8));
		DFEsmStateValue gapValue = state.value(dfeUInt(8));
		DFEsmStateValue captureGap = state.value(dfeBool(), false);


		captureGap.next <== false;
		IF (captureGap) {
			gapValue.next <== gapSizeInput;
		}

		outputRegValid.next <== false;
		gapSizeInput.read <== false;
		inputFifo.output.readEnable <== false;
		outputReg.next <== inputFifo.output.dataOut;

		DFEsmValue eof = SMUtils.extractField(inputFifo.output.dataOut, Types.linkWithGapIndicator, Types.linkWithGapIndicator.getEOF());

		SWITCH (currentState) {
			CASE (States.WAIT_FOR_GAP) {
				gapCounter.next <== 0;
				IF (~gapSizeInput.empty) {
					gapSizeInput.read <== true;
					captureGap.next <== true;
					currentState.next <== States.PASS_DATA;
				}
			}

			CASE (States.PASS_DATA) {
				IF (~(outputStall | inputFifo.output.empty)) {
					outputRegValid.next <== true;
					inputFifo.output.readEnable <== true;

					IF (eof) {
						currentState.next <== States.PASS_GAP;
					}
				}
			}

			CASE (States.PASS_GAP) {
				DFEsmValue firstCycle = gapCounter === 0;
				DFEsmValue lastCycle = gapValue -1 === gapCounter;

				SMUtils.assignField(outputReg.next, Types.linkWithGapIndicator, Types.linkWithGapIndicator.getGapIndicator(), true);
				SMUtils.assignField(outputReg.next, Types.linkWithGapIndicator, Types.linkWithGapIndicator.getSOF(), firstCycle);
				SMUtils.assignField(outputReg.next, Types.linkWithGapIndicator, Types.linkWithGapIndicator.getEOF(), lastCycle);


				IF (gapValue === 0) {
					currentState.next <== States.WAIT_FOR_GAP;
				}

				IF (~outputStall) {
					IF (gapValue !== gapCounter) {
						outputRegValid.next <== true;
						gapCounter.next <== gapCounter + 1;
					}

					IF (lastCycle) {
						currentState.next <== States.WAIT_FOR_GAP;
					}
				}
			}
		}



	}
}
