package com.maxeler.examples.signExtender;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.networking.v1.framed_kernels.ByteOrder;
import com.maxeler.networking.v1.framed_kernels.FrameData;
import com.maxeler.networking.v1.framed_kernels.FrameFormat;
import com.maxeler.networking.v1.framed_kernels.ThroughputFramedKernel;
import com.maxeler.networking.v1.kernel_types.SimpleFramedLinkType;
import com.maxeler.networking.v1.kernel_types.UDPOneToOneRXType;

public class SignExtKernel extends ThroughputFramedKernel {
	public static final String INPUT_UDP = "udpIn";
	public static final String OUTPUT_VALUES = "myOutput";

	public static final int WORD_SIZE_BYTES = 8;

	public static final SimpleFramedLinkType outputLinkType = new SimpleFramedLinkType();

	private static class OutputFormat extends FrameFormat {
		public OutputFormat() {
			super(ByteOrder.LITTLE_ENDIAN);

			addField("a", dfeRawBits(64));
			addField("b", dfeRawBits(64));
			addField("c", dfeRawBits(32));
		}
	}

	SignExtKernel(KernelParameters parameters) {
		super(parameters);

		DFEStructType inputType = new UDPOneToOneRXType().getDFEStructType();

		NonBlockingInput<DFEStruct> theInput = io.nonBlockingInput(INPUT_UDP, inputType,
				constant.var(true),
				inputType.getPositionForField(UDPOneToOneRXType.EOF),
				DelimiterMode.EOF_POSITION,
				3,
				NonBlockingMode.NO_TRICKLING);

		DFEStruct inputStruct = theInput.data;
		DFEVar valid = theInput.valid;

		DFEVar sof = inputStruct[UDPOneToOneRXType.SOF];

		// Take data from frames and expose as useful data
		IncomingData packet = new IncomingData(this, inputStruct, valid);

		// Output frame of padded values
		FrameData<OutputFormat> frameOut = toOutputFrame(packet.fieldA, packet.fieldB, packet.fieldC);
		io.frameOutput(OUTPUT_VALUES, frameOut, constant.var(true), sof & valid);
	}

	private FrameData<OutputFormat> toOutputFrame(final DFEVar a, final DFEVar b, final DFEVar c) {
		OutputFormat outputFormat = new OutputFormat();
		FrameData<OutputFormat> frameOut = new FrameData<OutputFormat>(
				this,
				outputFormat,
				outputLinkType
		);

		frameOut["a"] <== a;
		frameOut["b"] <== b;
		frameOut["c"] <== c;

		return frameOut;
	}
}

